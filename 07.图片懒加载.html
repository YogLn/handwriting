<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      img {
        display: block;
        width: 400px;
        height: 300px;
      }
    </style>
  </head>
  <body>
    <p>
      其中一个得到改进的是在可能的情况下从 Maps 和 Sets 转移到WeakMaps 和WeakSets。 那是什么，为什么这么重要？ 如果你在
      Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。 其中一个得到改进的是在可能的情况下从
      Maps 和 Sets 转移到WeakMaps 和WeakSets。 那是什么，为什么这么重要？ 如果你在 Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。 其中一个得到改进的是在可能的情况下从
      Maps 和 Sets 转移到WeakMaps 和WeakSets。 那是什么，为什么这么重要？ 如果你在 Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。 其中一个得到改进的是在可能的情况下从
      Maps 和 Sets 转移到WeakMaps 和WeakSets。 那是什么，为什么这么重要？ 如果你在 Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。 其中一个得到改进的是在可能的情况下从
      Maps 和 Sets 转移到WeakMaps 和WeakSets。 那是什么，为什么这么重要？ 如果你在 Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。 其中一个得到改进的是在可能的情况下从
      Maps 和 Sets 转移到WeakMaps 和WeakSets。 那是什么，为什么这么重要？ 如果你在 Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。 Maps 和 Sets 转移到WeakMaps
      和WeakSets。 那是什么，为什么这么重要？ 如果你在 Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。 其中一个得到改进的是在可能的情况下从
      Maps 和 Sets 转移到WeakMaps 和WeakSets。 那是什么，为什么这么重要？ 如果你在 Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。 Maps 和 Sets 转移到WeakMaps
      和WeakSets。 那是什么，为什么这么重要？ 如果你在 Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。 其中一个得到改进的是在可能的情况下从
      Maps 和 Sets 转移到WeakMaps 和WeakSets。 那是什么，为什么这么重要？ 如果你在 Maps或 Sets
      中存储东西，你会对这些东西做一个引用。这意味着，只要Map或Set被使用，这个东西就不会被垃圾收集器从内存中释放。
      通常这是有意义的。但有时候不是。特别是当你写一些代码，只是深入到数据的正常工作流中。例如，通过在系统中流动的数据中添加诊断数据。
      当你需要时，你希望数据被释放，你不希望保留保留数据的权利。 这就是 WeakMaps 和 WeakSets
      开始发挥作用的地方，Vue现在在内部更多地使用这些来防止内存泄漏并提高整体性能。
    </p>
    <img data-src="./images/img_1.JPG" />
    <img data-src="./images/img_2.JPG" />
    <img data-src="./images/img_3.JPG" />
    <img data-src="./images/img_4.JPG" />
    <script>
      // const observer = new IntersectionObserver(callback);
      // observer.observe(DOM)
      // observer.unobserve(DOM);
      const callback = (entries) => {
        console.log('entries', entries);
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            console.log('触发');
            const image = entry.target;
            const data_src = image.getAttribute('data-src');
            image.setAttribute('src', data_src);
            observer.unobserve(image);
          }
        });
      };

      const observer = new IntersectionObserver(callback);
      const images = document.querySelectorAll('img');
      images.forEach((image) => {
        observer.observe(image);
      });
    </script>
  </body>
</html>
